// Generated by CoffeeScript 1.4.0
(function() {
  var Dataset, LS, allowed_aggregation, bamboo_url, dataset_exists, dbg, ensure_jquery, is_aggregation, jsonify, noop, settings, _add_aggregation, _add_calculation, _create_dataset, _delete_dataset, _delete_row, _get_row, _join, _merge, _query, _query_aggregations, _query_calculations, _query_info, _remove_aggregation, _remove_calculation, _reset, _run_query, _summary, _uniqueId, _uniqueIdCount, _update, _update_row,
    __slice = [].slice;

  settings = {
    URL: "http://bamboo.io",
    DEBUG: true
  };

  dbg = function() {
    return settings.DEBUG;
  };

  jsonify = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return JSON.stringify.apply(this, args);
  };

  ensure_jquery = function() {
    if (typeof $ === "undefined" || $ === null) {
      throw new Error("jQuery is not available.");
    }
  };

  bamboo_url = function(section, id, operation, name) {
    var pieces;
    if (section == null) {
      section = "datasets";
    }
    pieces = [settings.URL, section];
    if (id != null) {
      pieces.push(id);
      if (operation != null) {
        pieces.push(operation);
        if (name != null) {
          pieces.push(name);
        }
      }
    }
    return pieces.join('/');
  };

  allowed_aggregation = ['max', 'min', 'mean', 'median', 'sum', 'ratio', 'count', 'argmax', 'newest'];

  _run_query = function(url, async, opts) {
    var promise;
    if (async == null) {
      async = true;
    }
    if (opts == null) {
      opts = {};
    }
    ensure_jquery();
    opts.url = url;
    if (!opts.async) {
      opts.async = async;
    }
    if (!opts.dataType) {
      opts.dataType = 'json';
    }
    if (!opts.crossDomain) {
      opts.crossDomain = true;
    }
    promise = $.ajax(opts);
    return promise;
  };

  _create_dataset = function(urlOrFile, async) {
    var opts;
    opts = {
      data: {
        url: urlOrFile
      },
      type: 'POST',
      dataType: 'json'
    };
    return _run_query(bamboo_url('datasets'), async, opts);
  };

  _delete_dataset = function(dataset_id, async) {
    var opts;
    opts = {
      type: 'DELETE',
      dataType: 'json'
    };
    return _run_query(bamboo_url('datasets', dataset_id), async, opts);
  };

  _query_info = function(dataset_id, async) {
    var opts;
    opts = {};
    return _run_query(bamboo_url('datasets', dataset_id, 'info'), async, opts);
  };

  _query = function(dataset_id, filter, select, limit, async) {
    var opts;
    opts = {
      data: {}
    };
    if (filter) {
      opts.data.query = JSON.stringify(filter);
    }
    if (select) {
      opts.data.select = JSON.stringify(select);
    }
    if (limit) {
      opts.data.limit = limit;
    }
    return _run_query(bamboo_url('datasets', dataset_id), async, opts);
  };

  _summary = function(dataset_id, select, group, async) {
    var opts;
    if (select == null) {
      select = "all";
    }
    if (group == null) {
      group = null;
    }
    select = typeof select === "string" ? select : JSON.stringify(select);
    opts = {
      data: {}
    };
    opts.data.select = select;
    if (group) {
      opts.data.group = group;
    }
    return _run_query(bamboo_url('datasets', dataset_id, 'summary'), async, opts);
  };

  _add_calculation = function(dataset_id, name, formula, async) {
    var opts;
    if (is_aggregation(formula)) {
      throw new Error("Error: this formula indicates it's aggregation                  instead of calculation, please use Dataset.add_aggregation instead");
    }
    opts = {
      data: {}
    };
    opts.data.name = name;
    opts.data.formula = formula;
    opts.type = 'POST';
    return _run_query(bamboo_url('calculations', dataset_id), async, opts);
  };

  _remove_calculation = function(dataset_id, name, async) {
    var opts;
    opts = {
      data: {}
    };
    opts.type = 'DELETE';
    return _run_query(bamboo_url('datasets', dataset_id, 'calculations', name), async, opts);
  };

  _query_calculations = function(dataset_id, async) {
    return _run_query(bamboo_url('datasets', dataset_id, 'calculations'), async);
  };

  _add_aggregation = function(dataset_id, name, formula, groups, async) {
    var opts;
    if (groups == null) {
      groups = null;
    }
    if (is_aggregation(formula)) {
      opts = {
        data: {}
      };
      opts.data.name = name;
      opts.data.formula = formula;
      opts.type = 'POST';
      if (groups !== null) {
        if (groups instanceof Array) {
          opts.data.group = groups.join();
        } else {
          throw new Error("group must be an array");
        }
      }
      return _run_query(bamboo_url('calculations', dataset_id), async, opts);
    } else {
      throw new Error("ill formated aggregation formula, perhaps you are                looking for calculation instead of aggregation?");
    }
  };

  _remove_aggregation = function(dataset_id, name, async) {
    var opts;
    opts = {
      data: {}
    };
    opts.type = 'DELETE';
    return _run_query(bamboo_url('datasets', dataset_id, 'calculations', name), async, opts);
  };

  _query_aggregations = function(dataset_id, async) {
    return _run_query(bamboo_url('datasets', dataset_id, 'aggregations'), async);
  };

  _update = function(dataset_id, rows, async) {
    /*
      Updates this dataset with the rows given in {column: value} format.
      Any unspecified columns will result in n/a values.
    */

    var data, jsonified_rows, opts;
    if (!(rows instanceof Array)) {
      throw new Error("rows must be an array");
    }
    if (rows.length === 0) {
      throw new Error("rows cannot be empty");
    }
    jsonified_rows = JSON.stringify(rows);
    data = {
      update: jsonified_rows
    };
    opts = {
      type: "PUT",
      data: data
    };
    return _run_query(bamboo_url('datasets', dataset_id), async, opts);
  };

  _join = function(left_dataset_id, right_dataset_id, on_column, async) {
    /*
      Create a new dataset that is the result of a join, where this
      left_dataset is the lefthand side and *right_dataset* is the
      righthand side and *on* is the column on which to join.
      The column that is joined on must be unique in the righthand side
      and must exist in both datasets.
    */

    var data, opts;
    data = {
      dataset_id: left_dataset_id,
      other_dataset_id: right_dataset_id,
      on: on_column
    };
    opts = {
      type: "POST",
      data: data
    };
    return _run_query(bamboo_url("datasets", "join"), async, opts);
  };

  _merge = function(datasets, async) {
    var data, dataset_ids, opts;
    if (!(datasets instanceof Array)) {
      throw new Error("datasets for merging must be an array");
    }
    dataset_ids = JSON.stringify(datasets);
    data = {
      dataset_ids: dataset_ids
    };
    opts = {
      type: "POST",
      data: data
    };
    return _run_query(bamboo_url('datasets', 'merge'), async, opts);
  };

  _reset = function(dataset_id, urlToData, async) {
    var data, opts;
    data = {
      url: urlToData
    };
    opts = {
      type: "PUT",
      data: data
    };
    return _run_query(bamboo_url('datasets', dataset_id, 'reset'), async, opts);
  };

  _get_row = function(dataset_id, row_index, async) {
    var opts;
    opts = {};
    return _run_query(bamboo_url('datasets', dataset_id, 'row', row_index), async, opts);
  };

  _delete_row = function(dataset_id, row_index, async) {
    var opts;
    opts = {
      type: "DELETE"
    };
    return _run_query(bamboo_url('datasets', dataset_id, 'row', row_index), async, opts);
  };

  _update_row = function(dataset_id, row_index, update_data, async) {
    var data, opts, string_data;
    if (typeof update_data !== "string") {
      string_data = JSON.stringify(update_data);
    }
    data = {
      data: string_data
    };
    opts = {
      type: "PUT",
      data: data
    };
    return _run_query(bamboo_url('datasets', dataset_id, 'row', row_index), async, opts);
  };

  Dataset = (function() {

    function Dataset(data) {
      this.extend(data);
      this._ls = {};
      this._reqs = {};
      if ((this.url != null) && !(this.id != null) && this.autoload) {
        this.load_from_url();
      }
    }

    Dataset.prototype.extend = function(obj, override) {
      var key, val, _results;
      if (override == null) {
        override = false;
      }
      _results = [];
      for (key in obj) {
        val = obj[key];
        if (override || !(this[key] != null)) {
          _results.push(this[key] = val);
        }
      }
      return _results;
    };

    Dataset.prototype.load_status = function(for_what) {
      return this._ls[for_what] || LS.not_started;
    };

    Dataset.prototype.on_success = function(for_what, response, sync_cb) {
      if (sync_cb == null) {
        sync_cb = false;
      }
      if (dbg()) {
        log("successfully ran " + for_what + " query", this);
      }
      this._ls[for_what] = LS.complete;
      if (!!sync_cb) {
        sync_cb.apply(this, [response]);
      }
    };

    Dataset.prototype.on_failure = function(for_what, error, sync_cb) {
      if (sync_cb == null) {
        sync_cb = false;
      }
      if (dbg()) {
        log("failed to ran " + for_what + " query", this);
      }
      this._ls[for_what] = LS.failed;
    };

    Dataset.prototype.load_from_url = function(url, sync_cb) {
      var _this = this;
      if (url == null) {
        url = null;
      }
      if (sync_cb == null) {
        sync_cb = false;
      }
      ensure_jquery();
      if (url) {
        this.url = url;
      }
      if (!(this.url != null)) {
        throw new Error("Missing URL");
      }
      this._ls.from_url = LS.started;
      bamboo.create_dataset(this.url, !!sync_cb).then(function(response) {
        _this._ls.from_url = LS.complete;
        _this.extend(response);
        _this.on_success("from_url", response, sync_cb);
      }, function() {
        _this.on_failure("from_url", e, sync_cb);
      });
      return this;
    };

    Dataset.prototype.query_info = function(sync_cb) {
      var async,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      async = !!sync_cb;
      bamboo.query_info(this.id, !!sync_cb).then(function(response) {
        _this.info = response;
        _this.on_success("info", response, sync_cb);
      }, function(e) {
        this.on_failure("info", e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return this.info;
      }
    };

    Dataset.prototype.summary = function(summary_select, group, sync_cb) {
      var summary_select_str, summary_tmp_id,
        _this = this;
      if (summary_select == null) {
        summary_select = "all";
      }
      if (group == null) {
        group = null;
      }
      if (sync_cb == null) {
        sync_cb = false;
      }
      summary_select_str = typeof summary_select === "string" ? summary_select : JSON.stringify(summary_select);
      summary_tmp_id = "summary_" + summary_select_str;
      if (group != null) {
        summary_tmp_id += "_" + group;
      }
      if (this._summaries == null) {
        this._summaries = {};
      }
      bamboo.summary(this.id, summary_select, group, !!sync_cb).then(function(response) {
        if (summary_select === "all") {
          _this.summary_result = response;
        }
        _this._summaries[summary_tmp_id] = response;
        _this.on_success(summary_tmp_id, response, sync_cb);
      }, function(e) {
        _this.on_failure(summary_tmp_id, e, sync_cb);
      });
      if (!!sync_cb) {
        return this;
      } else {
        return this._summaries[summary_tmp_id];
      }
    };

    Dataset.prototype.select = function(obj, sync_cb) {
      var async, select_str, select_tmp_id,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      select_str = jsonify(obj);
      async = !!sync_cb;
      select_tmp_id = "select_" + select_str;
      if (this._selects == null) {
        this._selects = {};
      }
      bamboo.query(this.id, void 0, obj, void 0, async).then(function(response) {
        _this._selects[select_tmp_id] = response;
        _this.on_success(select_tmp_id, response, sync_cb);
      }, function(e) {
        _this.on_failure(select_tmp_id, e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return this._selects[select_tmp_id];
      }
    };

    Dataset.prototype.query = function(obj, sync_cb) {
      var async, query_str, query_tmp_id,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      query_str = jsonify(obj);
      async = !!sync_cb;
      query_tmp_id = "query_" + query_str;
      if (this._queries == null) {
        this._queries = {};
      }
      bamboo.query(this.id, obj, void 0, void 0, async).then(function(response) {
        _this._queries[query_tmp_id] = response;
        _this.on_success(query_tmp_id, response, sync_cb);
      }, function(e) {
        _this.on_failure(query_tmp_id, e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return this._queries[query_tmp_id];
      }
    };

    Dataset.prototype.query_dataset = function(sync_cb) {
      var async,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      async = !!sync_cb;
      bamboo.query(this.id, void 0, void 0, void 0, async).then(function(response) {
        _this.data = response;
        _this.on_success("dataset", response, sync_cb);
      }, function(e) {
        _this.on_failure("dataset", e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return this.data;
      }
    };

    Dataset.prototype.add_calculation = function(name, formula, sync_cb) {
      var async, for_what,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      if (this._calculations == null) {
        this._calculations = [];
      }
      async = !!sync_cb;
      for_what = "calculation_" + name;
      bamboo.add_calculation(this.id, name, formula, async).then(function(response) {
        _this._calculations.push(name);
        _this.on_success(for_what, response, sync_cb);
      }, function(e) {
        _this.on_failure(for_what, e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return name;
      }
    };

    Dataset.prototype.query_calculations = function(sync_cb) {
      var async, for_what,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      async = !!sync_cb;
      for_what = "calculations";
      bamboo.query_calculations(this.id, async).then(function(response) {
        _this._calculations = response;
        _this.on_success(for_what, response, sync_cb);
      }, function(e) {
        _this.on_failure(for_what, e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return this._calculations;
      }
    };

    Dataset.prototype.remove_calculation = function(name, sync_cb) {
      var async, for_what,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      async = !!sync_cb;
      for_what = "delete calculation with name " + name + " in dataset " + this.id;
      if (this._calculations == null) {
        this._calculations = [];
      }
      bamboo.remove_calculation(this.id, name, async).then(function(response) {
        var calculation;
        calculation = _.find(_this._calculations, function(calc) {
          return calc.name === name;
        });
        if (calculation) {
          _this.calculations.pop(calculation);
        }
        _this.on_success(for_what, response, sync_cb);
      }, function(e) {
        _this.on_failure(for_what, e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return this._calculations;
      }
    };

    Dataset.prototype.add_aggregations = function(name, formula, groups, sync_cb) {
      var async, for_what,
        _this = this;
      if (groups == null) {
        groups = null;
      }
      if (sync_cb == null) {
        sync_cb = false;
      }
      async = !!sync_cb;
      for_what = "aggregation_" + name;
      bamboo.add_aggregation(this.id, name, formula, groups, async).then(function(response) {
        _this.on_success(for_what, response, sync_cb);
      }, function(e) {
        _this.on_failure(for_what, e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return name;
      }
    };

    Dataset.prototype.query_aggregations = function(sync_cb) {
      var async, for_what,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      async = !!sync_cb;
      for_what = "aggregations";
      bamboo.query_aggregations(this.id, async).then(function(response) {
        _this.aggregations = response;
        _this.on_success(for_what, response, sync_cb);
      }, function(e) {
        _this.on_failure(for_what, e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return this.aggregations;
      }
    };

    Dataset.prototype.remove_aggregations = function(name, sync_cb) {
      var async, for_what,
        _this = this;
      if (sync_cb == null) {
        sync_cb = false;
      }
      async = !!sync_cb;
      for_what = "delete aggregation under name " + name + " in dataset " + this.id;
      if (this.aggregations == null) {
        this.aggregations = {};
      }
      bamboo.remove_aggregation(this.id, name, async).then(function(response) {
        if (_this.aggregations[name]) {
          delete _this.aggregations[name];
        }
        _this.on_success(for_what, response, sync_cb);
      }, function(e) {
        _this.on_failure(for_what, e, sync_cb);
      });
      if (async) {
        return this;
      } else {
        return this.aggregations;
      }
    };

    Dataset.prototype.join = function(left, right, on_column, cb) {
      /*
          Create a new dataset that is the result of a join, where this
          left_dataset is the lefthand side and *right_dataset* is the
          righthand side and *on* is the column on which to join.
          The column that is joined on must be unique in the righthand side
          and must exist in both datasets.
      */

      var data, opts, success_cb, url;
      url = bamboo_url("datasets", "join");
      data = {
        dataset_id: left,
        other_dataset_id: right,
        on: on_column
      };
      success_cb = function(response) {
        var joined;
        joined = new bamboo.Dataset({
          id: response.id
        });
        cb.call(null, joined);
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: "POST",
        data: data
      };
      return this._run_query("joined datasets " + left + " and " + right, url, false, success_cb, opts);
    };

    Dataset.prototype.merge = function(datasets, cb) {
      /*
          Create a new dataset that is a row-wise merge of those in *datasets*.
          Returns the new merged dataset.
      */

      var data, dataset_ids, opts, success_cb, url;
      if (!(datasets instanceof Array)) {
        throw new Error("datasets for merging must be an array");
      }
      url = bamboo_url('datasets', 'merge');
      dataset_ids = JSON.stringify(datasets);
      data = {
        dataset_ids: dataset_ids
      };
      success_cb = function(response) {
        var merged;
        merged = new bamboo.Dataset({
          id: response.id
        });
        console.log("merged id is " + merged.id);
        return cb(merged);
      };
      opts = {
        type: "POST",
        data: data
      };
      return this._run_query("merging datasets " + datasets, url, false, success_cb, opts);
    };

    Dataset.prototype.update = function(rows, sync_cb) {
      var data, jsonified_rows, opts, success_cb, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      /*
          Updates this dataset with the rows given in {column: value} format.
          Any unspecified columns will result in n/a values.
      */

      if (!(rows instanceof Array)) {
        throw new Error("rows must be an array");
      }
      if (rows.length === 0) {
        throw new Error("rows cannot be empty");
      }
      url = bamboo_url('datasets', this.id);
      jsonified_rows = JSON.stringify(rows);
      data = {
        update: jsonified_rows
      };
      success_cb = function(response) {
        if (sync_cb) {
          sync_cb.apply(this, arguments);
        }
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: "PUT",
        data: data
      };
      return this._run_query("updating dataset " + this.id, url, !!sync_cb, success_cb, opts);
    };

    Dataset.prototype["delete"] = function() {
      var complete;
      complete = false;
      $.ajax({
        type: "DELETE",
        url: this.bamboo_url(),
        async: false,
        success: function() {
          return complete = true;
        },
        error: function() {
          return complete = false;
        }
      });
      return complete;
    };

    return Dataset;

  })();

  dataset_exists = function(id) {
    /*
      Not perfect, but this could be a nice way to determine if a dataset exists.
      It returns a boolean value.
    */

    var ds, existence, fail_cb, opts, success_cb;
    existence = void 0;
    ds = new Dataset({
      id: id
    });
    success_cb = function(a, b, c, d, e) {
      existence = true;
    };
    fail_cb = function() {
      existence = false;
    };
    opts = {
      error: fail_cb
    };
    ds._run_query("existence", "" + (ds.bamboo_url()), false, success_cb, opts);
    return existence;
  };

  is_aggregation = function(formula) {
    var keyword_sel, regex, regex_str;
    keyword_sel = allowed_aggregation.join("|");
    regex_str = "^(" + keyword_sel + ")\\([^\\)]+\\)$";
    regex = new RegExp(regex_str);
    if (formula.match(regex) !== null) {
      return true;
    }
    return false;
  };

  LS = {
    not_started: "not_started",
    queued: "queued",
    started: "started",
    complete: "complete",
    failed: "failed"
  };

  this.bamboo = {
    bamboo_url: bamboo_url,
    dataset_exists: dataset_exists,
    settings: settings,
    Dataset: Dataset,
    is_aggregation: is_aggregation,
    create_dataset: _create_dataset,
    delete_dataset: _delete_dataset,
    query_info: _query_info,
    summary: _summary,
    query: _query,
    add_calculation: _add_calculation,
    remove_calculation: _remove_calculation,
    query_calculations: _query_calculations,
    add_aggregation: _add_aggregation,
    remove_aggregation: _remove_aggregation,
    query_aggregations: _query_aggregations,
    join: _join,
    merge: _merge,
    update: _update,
    reset: _reset,
    get_row: _get_row,
    delete_row: _delete_row,
    update_row: _update_row
  };

  noop = function() {};

  _uniqueIdCount = 0;

  _uniqueId = function(str) {
    return "" + str + "_" + (_uniqueIdCount++);
  };

  /*
  This is a shortcut for "console.log" that prevents
  the call from breaking in browsers where console is
  not defined.
  */


  this.log = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if ((typeof console !== "undefined" && console !== null) && (console.log != null)) {
      return console.log.apply(console, args);
    }
  };

}).call(this);
