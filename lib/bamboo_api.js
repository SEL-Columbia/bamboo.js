// Generated by CoffeeScript 1.4.0
(function() {
  var Dataset, LS, bamboo_url, dataset_exists, dbg, ensure_jquery, jsonify, noop, settings, _uniqueId, _uniqueIdCount,
    __slice = [].slice;

  settings = {
    URL: "http://bamboo.io",
    DEBUG: true
  };

  dbg = function() {
    return settings.DEBUG;
  };

  jsonify = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return JSON.stringify.apply(this, args);
  };

  ensure_jquery = function() {
    if (typeof $ === "undefined" || $ === null) {
      throw new Error("jQuery is not available.");
    }
  };

  bamboo_url = function(section, id, name) {
    var pieces;
    if (section == null) {
      section = "datasets";
    }
    pieces = [settings.URL, section];
    if (id != null) {
      pieces.push(id);
      if (name != null) {
        pieces.push(name);
      }
    }
    return pieces.join('/');
  };

  Dataset = (function() {

    function Dataset(data) {
      this.extend(data);
      this._ls = {};
      this._reqs = {};
      if ((this.url != null) && !(this.id != null) && this.autoload) {
        this.load_from_url();
      }
    }

    Dataset.prototype.extend = function(obj, override) {
      var key, val, _results;
      if (override == null) {
        override = false;
      }
      _results = [];
      for (key in obj) {
        val = obj[key];
        if (override || !(this[key] != null)) {
          _results.push(this[key] = val);
        }
      }
      return _results;
    };

    Dataset.prototype.load_status = function(for_what) {
      if (!(this._ls[for_what] != null)) {
        return this._ls[for_what] = LS.not_started;
      }
    };

    Dataset.prototype.load_from_url = function(url, sync_cb) {
      var _this = this;
      if (url == null) {
        url = false;
      }
      if (sync_cb == null) {
        sync_cb = false;
      }
      ensure_jquery();
      if (url) {
        this.url = url;
      }
      if (!(this.url != null)) {
        throw new Error("Missing URL");
      }
      this._ls.from_url = LS.started;
      this._reqs.from_url = $.ajax({
        async: !!sync_cb,
        data: {
          url: this.url
        },
        type: 'POST',
        dataType: 'json',
        url: bamboo_url('datasets'),
        fail: function() {
          return this._ls.from_url = LS.failed;
        },
        success: function(response) {
          _this._ls.from_url = LS.complete;
          _this.extend(response);
          if (dbg()) {
            log("dataset.load_from_url() response", jsonify(response));
          }
          if (!!sync_cb) {
            return sync_cb.apply(_this, arguments);
          }
        }
      });
      return this;
    };

    Dataset.prototype.bamboo_url = function() {
      if (!(this.id != null)) {
        throw new Error("Missing dataset ID. " + "Run 'dataset.load_from_url()'.");
      }
      return bamboo_url("datasets", this.id);
    };

    Dataset.prototype._run_query = function(for_what, url, async, cb, opts) {
      var _this = this;
      if (opts == null) {
        opts = {};
      }
      ensure_jquery();
      this._ls[for_what] = LS.started;
      if (opts.async == null) {
        opts.async = async;
      }
      opts.url = url;
      if (opts.dataType == null) {
        opts.dataType = 'json';
      }
      opts.success = function(response, status, _req) {
        if (dbg()) {
          log("successfully ran " + for_what + " query", _this);
        }
        _this._ls[for_what] = LS.complete;
        return cb.apply(_this, [response, status, _req]);
      };
      this._reqs[for_what] = $.ajax(opts);
      return this;
    };

    Dataset.prototype.query_info = function(sync_cb) {
      var url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      url = "" + (this.bamboo_url()) + "/info";
      return this._run_query("info", url, !!sync_cb, function(response, status, _req) {
        this.info = response;
        if (!!sync_cb) {
          return sync_cb.apply(this, [response, status, _req]);
        }
      });
    };

    Dataset.prototype.summary = function(summary_select, group, sync_cb) {
      var async, summary_select_str, summary_tmp_id, url;
      if (summary_select == null) {
        summary_select = "all";
      }
      if (group == null) {
        group = null;
      }
      if (sync_cb == null) {
        sync_cb = false;
      }
      summary_select_str = typeof summary_select === "string" ? summary_select : JSON.stringify(summary_select);
      url = "" + (this.bamboo_url()) + "/summary?select=" + summary_select_str;
      if (group) {
        url = url + "&group=" + group;
      }
      async = !!sync_cb;
      summary_tmp_id = "summary_" + summary_select_str;
      if (this._summaries == null) {
        this._summaries = {};
      }
      this._run_query(summary_tmp_id, url, async, function(r, status, _req) {
        if (summary_select === "all") {
          this.summary_result = r;
        }
        this._summaries[summary_tmp_id] = r;
        if (sync_cb) {
          return sync_cb.apply(this, [r, status, _req]);
        }
      });
      if (async) {
        return this;
      } else {
        return this._summaries[summary_tmp_id];
      }
    };

    Dataset.prototype.select = function(obj, sync_cb) {
      var async, select_str, select_tmp_id, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      select_str = jsonify(obj);
      async = !!sync_cb;
      url = "" + (this.bamboo_url()) + "?select=" + select_str;
      select_tmp_id = "select_" + select_str;
      if (this._selects == null) {
        this._selects = {};
      }
      this._run_query(select_tmp_id, url, async, function(r, status, _req) {
        this._selects[select_tmp_id] = r;
        if (sync_cb) {
          return sync_cb.apply(this, [r, status, _req]);
        }
      });
      if (async) {
        return this;
      } else {
        return this._selects[select_tmp_id];
      }
    };

    Dataset.prototype.query = function(obj, sync_cb) {
      var async, query_str, query_tmp_id, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      query_str = jsonify(obj);
      async = !!sync_cb;
      url = "" + (this.bamboo_url()) + "?query=" + query_str;
      query_tmp_id = "query_" + query_str;
      if (this._queries == null) {
        this._queries = {};
      }
      this._run_query(query_tmp_id, url, async, function(r, status, _req) {
        this._queries[query_tmp_id] = r;
        if (sync_cb) {
          return sync_cb.apply(this, [r, status, _req]);
        }
      });
      if (async) {
        return this;
      } else {
        return this._queries[query_tmp_id];
      }
    };

    Dataset.prototype.query_dataset = function(sync_cb) {
      if (sync_cb == null) {
        sync_cb = false;
      }
      return this._run_query("dataset", bamboo_url("datasets", this.id), !!sync_cb, function(r) {
        this.data = r;
        if (!!sync_cb) {
          return sync_cb.apply(this, [response, status, _req]);
        }
      });
    };

    Dataset.prototype.add_calculation = function(name, formula, sync_cb) {
      var calc_id, data, opts, success_cb, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      calc_id = _uniqueId("calculation");
      url = bamboo_url("calculations", this.id);
      data = {
        name: name,
        formula: formula
      };
      success_cb = function(response) {
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: 'POST',
        data: data
      };
      return this._run_query("calculation_" + calc_id, url, false, success_cb, opts);
    };

    Dataset.prototype.query_calculations = function(sync_cb) {
      if (sync_cb == null) {
        sync_cb = false;
      }
      return this._run_query("calculations", bamboo_url("datasets", this.id, "calculations"), false, function(r) {
        this.calculations = r;
        if (!!sync_cb) {
          return sync_cb.apply(this, [response, status, _req]);
        }
      });
    };

    Dataset.prototype.remove_calculation = function(name) {
      var data, opts, success_cb, url;
      url = bamboo_url("calculations", this.id);
      data = {
        name: name
      };
      success_cb = function(response) {
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: 'DELETE',
        data: data
      };
      return this._run_query("delete calculation under name " + name + " in dataset " + this.id, url, false, success_cb, opts);
    };

    Dataset.prototype.query_aggregations = function(sync_cb) {
      if (sync_cb == null) {
        sync_cb = false;
      }
      return this._run_query("aggregations", bamboo_url("datasets", this.id, "aggregations"), !!sync_cb, function(r) {
        this.aggregations = r;
        if (!!sync_cb) {
          return sync_cb.apply(this, [response, status, _req]);
        }
      });
    };

    Dataset.prototype["delete"] = function() {
      var complete;
      complete = false;
      $.ajax({
        type: "DELETE",
        url: this.bamboo_url(),
        async: false,
        success: function() {
          return complete = true;
        },
        error: function() {
          return complete = false;
        }
      });
      return complete;
    };

    return Dataset;

  })();

  dataset_exists = function(id) {
    /*
      Not perfect, but this could be a nice way to determine if a dataset exists.
      It returns a boolean value.
    */

    var ds, existence, fail_cb, opts, success_cb;
    existence = void 0;
    ds = new Dataset({
      id: id
    });
    success_cb = function(a, b, c, d, e) {
      return existence = true;
    };
    fail_cb = function() {
      return existence = false;
    };
    opts = {
      error: fail_cb
    };
    ds._run_query("existence", "" + (ds.bamboo_url()), false, success_cb, opts);
    return existence;
  };

  LS = {
    not_started: "not_started",
    queued: "queued",
    started: "started",
    complete: "complete",
    failed: "failed"
  };

  this.bamboo = {
    Dataset: Dataset,
    dataset_exists: dataset_exists,
    settings: settings
  };

  noop = function() {};

  _uniqueIdCount = 0;

  _uniqueId = function(str) {
    return "" + str + "_" + (_uniqueIdCount++);
  };

  /*
  This is a shortcut for "console.log" that prevents
  the call from breaking in browsers where console is
  not defined.
  */


  this.log = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if ((typeof console !== "undefined" && console !== null) && (console.log != null)) {
      return console.log.apply(console, args);
    }
  };

}).call(this);
