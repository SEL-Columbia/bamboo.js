// Generated by CoffeeScript 1.4.0
(function() {
  var Dataset, LS, allowed_aggregation, bamboo_url, dataset_exists, dbg, ensure_jquery, is_aggregation, jsonify, noop, settings, _add_aggregation, _add_calculation, _create_dataset, _delete_dataset, _join, _merge, _query, _query_aggregations, _query_calculations, _query_info, _remove_aggregation, _remove_calculation, _run_query, _summary, _uniqueId, _uniqueIdCount, _update,
    __slice = [].slice;

  settings = {
    URL: "http://bamboo.io",
    DEBUG: true
  };

  dbg = function() {
    return settings.DEBUG;
  };

  jsonify = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return JSON.stringify.apply(this, args);
  };

  ensure_jquery = function() {
    if (typeof $ === "undefined" || $ === null) {
      throw new Error("jQuery is not available.");
    }
  };

  bamboo_url = function(section, id, operation, name) {
    var pieces;
    if (section == null) {
      section = "datasets";
    }
    pieces = [settings.URL, section];
    if (id != null) {
      pieces.push(id);
      if (operation) {
        pieces.push(operation);
        if (name) {
          pieces.push(name);
        }
      }
    }
    return pieces.join('/');
  };

  allowed_aggregation = ['max', 'min', 'mean', 'median', 'sum', 'ratio', 'count', 'argmax', 'newest'];

  _run_query = function(url, async, opts) {
    var promise;
    if (async == null) {
      async = true;
    }
    if (opts == null) {
      opts = {};
    }
    ensure_jquery();
    opts.url = url;
    if (!opts.async) {
      opts.async = async;
    }
    if (!opts.dataType) {
      opts.dataType = 'json';
    }
    if (!opts.crossDomain) {
      opts.crossDomain = true;
    }
    promise = $.ajax(opts);
    return promise;
  };

  _create_dataset = function(urlOrFile, async) {
    var opts;
    opts = {
      data: {
        url: urlOrFile
      },
      type: 'POST',
      dataType: 'json'
    };
    return _run_query(bamboo_url('datasets'), async, opts);
  };

  _delete_dataset = function(dataset_id, async) {
    var opts;
    opts = {
      type: 'DELETE',
      dataType: 'json'
    };
    return _run_query(bamboo_url('datasets', dataset_id), async, opts);
  };

  _query_info = function(dataset_id, async) {
    var opts;
    opts = {};
    return _run_query(bamboo_url('datasets', dataset_id, 'info'), async, opts);
  };

  _query = function(dataset_id, filter, select, limit, async) {
    var opts;
    opts = {
      data: {}
    };
    if (filter) {
      opts.data.query = JSON.stringify(filter);
    }
    if (select) {
      opts.data.select = JSON.stringify(select);
    }
    if (limit) {
      opts.data.limit = limit;
    }
    return _run_query(bamboo_url('datasets', dataset_id), async, opts);
  };

  _summary = function(dataset_id, select, group, async) {
    var opts;
    if (select == null) {
      select = "all";
    }
    if (group == null) {
      group = null;
    }
    select = typeof select === "string" ? select : JSON.stringify(select);
    opts = {
      data: {}
    };
    opts.data.select = select;
    if (group) {
      opts.data.group = group;
    }
    return _run_query(bamboo_url('datasets', dataset_id, 'summary'), async, opts);
  };

  _add_calculation = function(dataset_id, name, formula, async) {
    var opts;
    opts = {
      data: {}
    };
    opts.data.name = name;
    opts.data.formula = formula;
    opts.type = 'POST';
    return _run_query(bamboo_url('calculations', dataset_id), async, opts);
  };

  _remove_calculation = function(dataset_id, name, async) {
    var opts;
    opts = {
      data: {}
    };
    opts.type = 'DELETE';
    return _run_query(bamboo_url('datasets', dataset_id, 'calculations', name), async, opts);
  };

  _query_calculations = function(dataset_id, async) {
    return _run_query(bamboo_url('datasets', dataset_id, 'calculations'), async);
  };

  _add_aggregation = function(dataset_id, name, formula, groups, async) {
    var opts;
    if (groups == null) {
      groups = null;
    }
    if (is_aggregation(formula)) {
      opts = {
        data: {}
      };
      opts.data.name = name;
      opts.data.formula = formula;
      opts.type = 'POST';
      if (groups !== null) {
        if (groups instanceof Array) {
          opts.data.group = groups.join();
        } else {
          throw new Error("group must be an array");
        }
      }
      return _run_query(bamboo_url('calculations', dataset_id), async, opts);
    } else {
      throw new Error("ill formated aggregation formula, perhaps you are            looking for calculation instead of aggregation?");
    }
  };

  _remove_aggregation = function(dataset_id, name, async) {
    var opts;
    opts = {
      data: {}
    };
    opts.type = 'DELETE';
    return _run_query(bamboo_url('datasets', dataset_id, 'calculations', name), async, opts);
  };

  _query_aggregations = function(dataset_id, async) {
    return _run_query(bamboo_url('datasets', dataset_id, 'aggregations'), async);
  };

  _update = function(dataset_id, rows, async) {
    /*
      Updates this dataset with the rows given in {column: value} format.
      Any unspecified columns will result in n/a values.
    */

    var data, jsonified_rows, opts;
    if (!(rows instanceof Array)) {
      throw new Error("rows must be an array");
    }
    if (rows.length === 0) {
      throw new Error("rows cannot be empty");
    }
    jsonified_rows = JSON.stringify(rows);
    data = {
      update: jsonified_rows
    };
    opts = {
      type: "PUT",
      data: data
    };
    return _run_query(bamboo_url('datasets', dataset_id), async, opts);
  };

  _join = function(left_dataset_id, right_dataset_id, on_column, async) {
    /*
      Create a new dataset that is the result of a join, where this
      left_dataset is the lefthand side and *right_dataset* is the
      righthand side and *on* is the column on which to join.
      The column that is joined on must be unique in the righthand side
      and must exist in both datasets.
    */

    var data, opts;
    data = {
      dataset_id: left_dataset_id,
      other_dataset_id: right_dataset_id,
      on: on_column
    };
    opts = {
      type: "POST",
      data: data
    };
    return _run_query(bamboo_url("datasets", "join"), async, opts);
  };

  _merge = function(datasets, async) {
    var data, dataset_ids, opts;
    if (!(datasets instanceof Array)) {
      throw new Error("datasets for merging must be an array");
    }
    dataset_ids = JSON.stringify(datasets);
    data = {
      dataset_ids: dataset_ids
    };
    opts = {
      type: "POST",
      data: data
    };
    return _run_query(bamboo_url('datasets', 'merge'), async, opts);
  };

  Dataset = (function() {

    function Dataset(data) {
      this.extend(data);
      this._ls = {};
      this._reqs = {};
      if ((this.url != null) && !(this.id != null) && this.autoload) {
        this.load_from_url();
      }
    }

    Dataset.prototype.extend = function(obj, override) {
      var key, val, _results;
      if (override == null) {
        override = false;
      }
      _results = [];
      for (key in obj) {
        val = obj[key];
        if (override || !(this[key] != null)) {
          _results.push(this[key] = val);
        }
      }
      return _results;
    };

    Dataset.prototype.load_status = function(for_what) {
      return this._ls[for_what] || LS.not_started;
    };

    Dataset.prototype.load_from_url = function(url, sync_cb) {
      var _this = this;
      if (url == null) {
        url = false;
      }
      if (sync_cb == null) {
        sync_cb = false;
      }
      ensure_jquery();
      if (url) {
        this.url = url;
      }
      if (!(this.url != null)) {
        throw new Error("Missing URL");
      }
      this._ls.from_url = LS.started;
      this._reqs.from_url = $.ajax({
        async: !!sync_cb,
        data: {
          url: this.url
        },
        type: 'POST',
        dataType: 'json',
        url: bamboo_url('datasets'),
        error: function() {
          _this._ls.from_url = LS.failed;
        },
        success: function(response) {
          _this._ls.from_url = LS.complete;
          _this.extend(response);
          if (dbg()) {
            log("dataset.load_from_url() response", jsonify(response));
          }
          if (!!sync_cb) {
            sync_cb.apply(_this, arguments);
          }
        }
      });
      return this;
    };

    Dataset.prototype.bamboo_url = function() {
      if (!(this.id != null)) {
        throw new Error("Missing dataset ID. " + "Run 'dataset.load_from_url()'.");
      }
      return bamboo_url("datasets", this.id);
    };

    Dataset.prototype._run_query = function(for_what, url, async, cb, opts) {
      var _this = this;
      if (opts == null) {
        opts = {};
      }
      ensure_jquery();
      this._ls[for_what] = LS.started;
      if (opts.async == null) {
        opts.async = async;
      }
      opts.url = url;
      if (opts.dataType == null) {
        opts.dataType = 'json';
      }
      opts.success = function(response, status, _req) {
        if (dbg()) {
          log("successfully ran " + for_what + " query", _this);
        }
        _this._ls[for_what] = LS.complete;
        return cb.apply(_this, [response, status, _req]);
      };
      opts.error = function(e) {
        if (dbg()) {
          log("failed to ran " + for_what + " query", _this);
        }
        return _this._ls[for_what] = LS.failed;
      };
      this._reqs[for_what] = $.ajax(opts);
      return this;
    };

    Dataset.prototype.query_info = function(sync_cb) {
      var url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      url = "" + (this.bamboo_url()) + "/info";
      return this._run_query("info", url, !!sync_cb, function(response, status, _req) {
        this.info = response;
        if (!!sync_cb) {
          return sync_cb.apply(this, [response, status, _req]);
        }
      });
    };

    Dataset.prototype.summary = function(summary_select, group, sync_cb) {
      var async, summary_select_str, summary_tmp_id, url;
      if (summary_select == null) {
        summary_select = "all";
      }
      if (group == null) {
        group = null;
      }
      if (sync_cb == null) {
        sync_cb = false;
      }
      summary_select_str = typeof summary_select === "string" ? summary_select : JSON.stringify(summary_select);
      url = "" + (this.bamboo_url()) + "/summary?select=" + summary_select_str;
      if (group != null) {
        url += "&group=" + group;
      }
      async = !!sync_cb;
      summary_tmp_id = "summary_" + summary_select_str;
      if (group != null) {
        summary_tmp_id += "_" + group;
      }
      if (this._summaries == null) {
        this._summaries = {};
      }
      this._run_query(summary_tmp_id, url, async, function(r, status, _req) {
        if (summary_select === "all") {
          this.summary_result = r;
        }
        this._summaries[summary_tmp_id] = r;
        if (sync_cb) {
          return sync_cb.apply(this, [r, status, _req]);
        }
      });
      if (async) {
        return this;
      } else {
        return this._summaries[summary_tmp_id];
      }
    };

    Dataset.prototype.select = function(obj, sync_cb) {
      var async, select_str, select_tmp_id, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      select_str = jsonify(obj);
      async = !!sync_cb;
      url = "" + (this.bamboo_url()) + "?select=" + select_str;
      select_tmp_id = "select_" + select_str;
      if (this._selects == null) {
        this._selects = {};
      }
      this._run_query(select_tmp_id, url, async, function(r, status, _req) {
        this._selects[select_tmp_id] = r;
        if (sync_cb) {
          return sync_cb.apply(this, [r, status, _req]);
        }
      });
      if (async) {
        return this;
      } else {
        return this._selects[select_tmp_id];
      }
    };

    Dataset.prototype.query = function(obj, sync_cb) {
      var async, query_str, query_tmp_id, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      query_str = jsonify(obj);
      async = !!sync_cb;
      url = "" + (this.bamboo_url()) + "?query=" + query_str;
      query_tmp_id = "query_" + query_str;
      if (this._queries == null) {
        this._queries = {};
      }
      this._run_query(query_tmp_id, url, async, function(r, status, _req) {
        this._queries[query_tmp_id] = r;
        if (sync_cb) {
          return sync_cb.apply(this, [r, status, _req]);
        }
      });
      if (async) {
        return this;
      } else {
        return this._queries[query_tmp_id];
      }
    };

    Dataset.prototype.query_dataset = function(sync_cb) {
      if (sync_cb == null) {
        sync_cb = false;
      }
      return this._run_query("dataset", bamboo_url("datasets", this.id), !!sync_cb, function(r, status, _req) {
        this.data = r;
        if (!!sync_cb) {
          return sync_cb.apply(this, arguments);
        }
      });
    };

    Dataset.prototype.add_calculation = function(name, formula, sync_cb) {
      var calc_id, data, opts, success_cb, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      if (is_aggregation(formula)) {
        throw new Error("Error: this formula indicates it's aggregation        instead of calculation, please use Dataset.add_aggregation instead");
      }
      calc_id = _uniqueId("calculation");
      url = bamboo_url("calculations", this.id);
      data = {
        name: name,
        formula: formula
      };
      if (this.calculations == null) {
        this.calculations = [];
      }
      success_cb = function(response) {
        var calculation;
        calculation = {
          name: name,
          formula: formula
        };
        this.calculations.push(calculation);
        if (sync_cb) {
          sync_cb.apply(this, arguments);
        }
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: 'POST',
        data: data
      };
      return this._run_query("calculation_" + calc_id, url, false, success_cb, opts);
    };

    Dataset.prototype.query_calculations = function(sync_cb) {
      if (sync_cb == null) {
        sync_cb = false;
      }
      return this._run_query("calculations", bamboo_url("datasets", this.id, "calculations"), false, function(r) {
        this.calculations = r;
        if (!!sync_cb) {
          return sync_cb.apply(this, arguments);
        }
      });
    };

    Dataset.prototype.remove_calculation = function(name) {
      var opts, success_cb, url;
      url = bamboo_url("datasets", this.id, "calculations", name);
      success_cb = function(response) {
        var calculation;
        calculation = _.find(this.calculations, function(calculation) {
          return calculation.name === name;
        });
        if (calculation) {
          this.calculations.pop(calculation);
        }
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: 'DELETE'
      };
      return this._run_query("delete calculation under name " + name + " in dataset " + this.id, url, false, success_cb, opts);
    };

    Dataset.prototype.add_aggregations = function(name, formula, groups, sync_cb) {
      var agg_id, data, opts, success_cb, url;
      if (groups == null) {
        groups = null;
      }
      if (sync_cb == null) {
        sync_cb = false;
      }
      if (is_aggregation(formula)) {
        agg_id = _uniqueId("aggregation");
        url = bamboo_url("calculations", this.id);
        data = {
          name: name,
          formula: formula
        };
        if (groups !== null) {
          if (groups instanceof Array) {
            data['group'] = groups.join();
          } else {
            throw new Error("group must be an array");
          }
        }
        success_cb = function(response) {
          if (sync_cb) {
            sync_cb.apply(this, arguments);
          }
          if (dbg()) {
            return log(response.success);
          }
        };
        opts = {
          type: 'POST',
          data: data
        };
        return this._run_query("aggregation_" + agg_id, url, false, success_cb, opts);
      } else {
        throw new Error("ill formated aggregation formula, perhaps you are        looking for calculation instead of aggregation?");
      }
    };

    Dataset.prototype.query_aggregations = function(sync_cb) {
      if (sync_cb == null) {
        sync_cb = false;
      }
      return this._run_query("aggregations", bamboo_url("datasets", this.id, "aggregations"), !!sync_cb, function(r) {
        this.aggregations = r;
        if (!!sync_cb) {
          return sync_cb.apply(this, arguments);
        }
      });
    };

    Dataset.prototype.remove_aggregations = function(name, sync_cb) {
      var opts, success_cb, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      url = bamboo_url("datasets", this.id, "calculations", name);
      success_cb = function(response) {
        if (!!sync_cb) {
          sync_cb.apply(this, arguments);
        }
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: 'DELETE'
      };
      return this._run_query("delete aggregation under name " + name + " in dataset " + this.id, url, false, success_cb, opts);
    };

    Dataset.prototype.join = function(left, right, on_column, cb) {
      /*
          Create a new dataset that is the result of a join, where this
          left_dataset is the lefthand side and *right_dataset* is the
          righthand side and *on* is the column on which to join.
          The column that is joined on must be unique in the righthand side
          and must exist in both datasets.
      */

      var data, opts, success_cb, url;
      url = bamboo_url("datasets", "join");
      data = {
        dataset_id: left,
        other_dataset_id: right,
        on: on_column
      };
      success_cb = function(response) {
        var joined;
        joined = new bamboo.Dataset({
          id: response.id
        });
        cb.call(null, joined);
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: "POST",
        data: data
      };
      return this._run_query("joined datasets " + left + " and " + right, url, false, success_cb, opts);
    };

    Dataset.prototype.merge = function(datasets, cb) {
      /*
          Create a new dataset that is a row-wise merge of those in *datasets*.
          Returns the new merged dataset.
      */

      var data, dataset_ids, opts, success_cb, url;
      if (!(datasets instanceof Array)) {
        throw new Error("datasets for merging must be an array");
      }
      url = bamboo_url('datasets', 'merge');
      dataset_ids = JSON.stringify(datasets);
      data = {
        dataset_ids: dataset_ids
      };
      success_cb = function(response) {
        var merged;
        merged = new bamboo.Dataset({
          id: response.id
        });
        console.log("merged id is " + merged.id);
        return cb(merged);
      };
      opts = {
        type: "POST",
        data: data
      };
      return this._run_query("merging datasets " + datasets, url, false, success_cb, opts);
    };

    Dataset.prototype.update = function(rows, sync_cb) {
      var data, jsonified_rows, opts, success_cb, url;
      if (sync_cb == null) {
        sync_cb = false;
      }
      /*
          Updates this dataset with the rows given in {column: value} format.
          Any unspecified columns will result in n/a values.
      */

      if (!(rows instanceof Array)) {
        throw new Error("rows must be an array");
      }
      if (rows.length === 0) {
        throw new Error("rows cannot be empty");
      }
      url = bamboo_url('datasets', this.id);
      jsonified_rows = JSON.stringify(rows);
      data = {
        update: jsonified_rows
      };
      success_cb = function(response) {
        if (sync_cb) {
          sync_cb.apply(this, arguments);
        }
        if (dbg()) {
          return log(response.success);
        }
      };
      opts = {
        type: "PUT",
        data: data
      };
      return this._run_query("updating dataset " + this.id, url, !!sync_cb, success_cb, opts);
    };

    Dataset.prototype["delete"] = function() {
      var complete;
      complete = false;
      $.ajax({
        type: "DELETE",
        url: this.bamboo_url(),
        async: false,
        success: function() {
          return complete = true;
        },
        error: function() {
          return complete = false;
        }
      });
      return complete;
    };

    return Dataset;

  })();

  dataset_exists = function(id) {
    /*
      Not perfect, but this could be a nice way to determine if a dataset exists.
      It returns a boolean value.
    */

    var ds, existence, fail_cb, opts, success_cb;
    existence = void 0;
    ds = new Dataset({
      id: id
    });
    success_cb = function(a, b, c, d, e) {
      existence = true;
    };
    fail_cb = function() {
      existence = false;
    };
    opts = {
      error: fail_cb
    };
    ds._run_query("existence", "" + (ds.bamboo_url()), false, success_cb, opts);
    return existence;
  };

  is_aggregation = function(formula) {
    var keyword_sel, regex, regex_str;
    keyword_sel = allowed_aggregation.join("|");
    regex_str = "^(" + keyword_sel + ")\\([^\\)]+\\)$";
    regex = new RegExp(regex_str);
    if (formula.match(regex) !== null) {
      return true;
    }
    return false;
  };

  LS = {
    not_started: "not_started",
    queued: "queued",
    started: "started",
    complete: "complete",
    failed: "failed"
  };

  this.bamboo = {
    bamboo_url: bamboo_url,
    dataset_exists: dataset_exists,
    settings: settings,
    is_aggregation: is_aggregation,
    create_dataset: _create_dataset,
    delete_dataset: _delete_dataset,
    query_info: _query_info,
    summary: _summary,
    query: _query,
    add_calculation: _add_calculation,
    remove_calculation: _remove_calculation,
    query_calculations: _query_calculations,
    add_aggregation: _add_aggregation,
    remove_aggregation: _remove_aggregation,
    query_aggregations: _query_aggregations,
    join: _join,
    merge: _merge,
    update: _update
  };

  noop = function() {};

  _uniqueIdCount = 0;

  _uniqueId = function(str) {
    return "" + str + "_" + (_uniqueIdCount++);
  };

  /*
  This is a shortcut for "console.log" that prevents
  the call from breaking in browsers where console is
  not defined.
  */


  this.log = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if ((typeof console !== "undefined" && console !== null) && (console.log != null)) {
      return console.log.apply(console, args);
    }
  };

}).call(this);
